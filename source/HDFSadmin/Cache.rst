Централизованное управление кэшем в HDFS
----------------------------------------

.. |br| raw:: html

   <br />


В данной главе приведены инструкции по настройке и использованию централизованного управления кэшем в **HDFS**. 
Централизованное управление кэшем позволяет указать пути к каталогам или файлам, которые будут кэшироваться **HDFS**, 
тем самым повышая производительность приложений, которые неоднократно обращаются к одним и тем же данным.



Обзор
^^^^^

Централизованное управление кэшем в **HDFS** – это точный механизм кэширования, который позволяет указывать пути к каталогам или файлам, которые будут кэшироваться **HDFS**. **NameNode** связывается с **DataNodes**, которые имеют требуемые доступные на диске блоки, и поручает **DataNodes** кэшировать блоки в кэшах.

Централизованное управление кэшем в **HDFS** дает много существенных преимуществ:

+	Точный кэш предотвращает вытеснение часто используемых данных из памяти. Это особенно важно, когда размер рабочего набора превышает размер оперативной памяти, который является общим для многих рабочих нагрузок HDFS;
+	Поскольку кэши данных DataNode управляются NameNode, приложения могут запрашивать набор местоположений кэшированных блоков при принятии решений о размещении задач. Совмещение задачи с кэшированной блочной копией повышает производительность чтения;
+	Когда блок кэшируется с помощью DataNode, клиенты могут использовать новый, более эффективный API-интерфейс с нулевой копией. Поскольку проверка контрольных сумм кэшированных данных выполняется DataNode один раз, при использовании этого нового API клиенты могут понести практически нулевые расходы;
+	Централизованное кэширование может улучшить общую эффективность использования памяти кластера. Когда используется ОС буферного кэша на каждом DataNode, повторные чтения блока приводят к тому, что все *<n>* копии блока перемещаются в буферный кэш. При централизованном управлении кэшем точно указывается только *<m>* копий *<n>*, тем самым сохраняя память *<n-m>*.



Кэширование
^^^^^^^^^^^

Централизованное управление кэшем полезно:

+	Для файлов, к которым неоднократно обращаются. Например, небольшая таблица фактов в Hive, которая часто используется, является хорошим кандидатом для кэширования. И наоборот, кэширование запроса годовой отчетности менее полезно, так как подобные данные, вероятно, могут быть прочитаны только один раз;
+	Для смешанной рабочей нагрузки с SLA-производительностью. Кэширование рабочего набора высокоприоритетной рабочей нагрузки гарантирует, что она не конкурирует с низкоприоритетными рабочими нагрузками для дискового ввода-вывода. 



Архитектура кеширования
^^^^^^^^^^^^^^^^^^^^^^^

На рисунке показана централизованная кэшированная архитектура управления (:ref:`Рис.1.<hdfsadmin_pic1>`).

.. _hdfsadmin_pic1:

.. figure:: imgs/hdfsadmin_pic1.*
   :align: center
   
   Рис.1. Архитектура кэширования
   
   
В данной архитектуре **NameNode** отвечает за координацию всех кэш-файлов с неактивными данными в кластере. **NameNode** периодически получает кэш-отчет кэш от каждого **DataNode**. Кэш-отчет описывает все блоки, кэшированные в **DataNode**. **NameNode** управляет кэшами **DataNode** с помощью кеш-копий и мгновенных команд *uncache*.

**NameNode** запрашивает набор **Cache Directives**, чтобы определить, какие контуры следует кэшировать. **Cache Directives** постоянно сохраняются в *fsimage* и журналах и могут быть добавлены, удалены и изменены с помощью **Java** и API-интерфейсов командной строки. В **NameNode** также хранится набор **Cache Pools**, являющийся административным объектом, который группирует **Cache Directives** для управления ресурсами, а также для обеспечения прав доступа.

**NameNode** периодически повторно сканирует пространство имен и актив **Cache Directives**, чтобы определить, какие блоки нужно кэшировать, а какие нет, и назначает задачи кэширования **DataNodes**. Повторное сканирование также может быть вызвано действиями пользователя, такими как добавление или удаление **Cache Directives** или удаление **Cache Pools**.

Блоки кэша, находящиеся в стадии разрабобтки, поврежденые или неполные, не кэшируются. Если **Cache Directives** содержит ссылку, адрес ссылки не кэшируется.

В настоящее время кеширование может применяться только к каталогам и файлам.



Терминология кэширования
^^^^^^^^^^^^^^^^^^^^^^^^


Cache Directive
~~~~~~~~~~~~~~~

**Cache Directive** определяет контур для кэширования. Пути могут указывать либо каталоги, либо файлы. Каталоги кэшируются не рекурсивно, то есть кэшируются только файлы в листинге каталога первого уровня.

**Cache Directives** также указывают дополнительные параметры, такие как фактор репликации кэша и время окончания. Фактор репликации указывает количество блочных реплик в кэше. Если несколько **Cache Directives** относятся к одному файлу, применяется максимальный коэффициент репликации кеша.

Время окончания задается в командной строке как жизненный период (*time-to-live* - *TTL*), который представляет собой относительное время действия в будущем. После истечения срока действия **Cache Directive** больше не учитывается **NameNode** при принятии решений кэширования.


Cache Pool
~~~~~~~~~~

**Cache Pool** - это административный объект, используемый для управления группами директив кэша. Кэш-пулы имеют UNIX-подобные разрешения, которые ограничивают доступ пользователей и групп к пулу. Разрешения на запись позволяют пользователям добавлять и удалять директивы кэша в пул. Разрешения на чтение позволяют пользователям просматривать директивы кэша в пуле и дополнительные метаданные. Execute-разрешение не используется.

**Cache Pools** также используются для управления ресурсами. Кэш-пулы могут обеспечить максимальный предел памяти, ограничивающий совокупное количество байтов, которые могут быть кэшированы директивами в пуле. Как правило, сумма лимитов пула приблизительно равна суммарной памяти, зарезервированной для кэширования **HDFS** в кластере. Кэш-пулы также мониторят ряд статистических данных, чтобы помочь пользователям кластера отслеживать, что в настоящее время кэшируется, и определить, что еще нужно кэшировать.

**Cache Pools** также могут обеспечить максимальный жизненный период, ограничив максимальное время истечения срока действия директив, добавляемых в пул.



Настройка централизованного кэширования
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Собственные библиотеки
~~~~~~~~~~~~~~~~~~~~~~

Для отгорождения блокировки файлов в памяти, **DataNode** использует собственный код *JNI* из *libhadoop.so*. 

.. important:: Обязательно включите *JNI*, если используется централизованное управление кешем HDFS


Свойства конфигурации
~~~~~~~~~~~~~~~~~~~~~

Свойства конфигурации для централизованного кэширования указаны в файле *hdfs-site.xml*.


Требуемые свойства
~~~~~~~~~~~~~~~~~~

В настоящее время требуется только одно свойство:

+ *dfs.datanode.max.locked.memory*. Это свойство определяет максимальный объем памяти (в байтах), который будет использовать DataNode для кеширования. Также необходимо увеличить размер "заблокированного объема памяти" *ulimit* (*ulimit -l*) пользователя DataNode, чтобы превысить этот параметр (более подробно описано в следующем разделе "Дополнительные свойства"). При настройке данного значения необходимо помнить, что пространство в памяти также понадобится и для других целей, таких как JNM и DataNode, а также страниц кеша операционной системы. 

Пример:

:command:`<property>`  |br| 
    :command:`<name>dfs.datanode.max.locked.memory</name>`  |br| 
    :command:`<value>268435456</value>`  |br| 
  :command:`</property>`



Дополнительные свойства
~~~~~~~~~~~~~~~~~~~~~~~

Следующие свойства не являются обязательными, но могут быть заданы в настройках:

+ *dfs.namenode.path.based.cache.refresh.interval.ms* число миллисекунд, которое NameNode использует между последующими повторными сканированиями кэша. По умолчанию этот параметр установлен на *300000*, что составляет пять минут. Пример:

  :command:`<property>` |br| 
      :command:`<name>dfs.namenode.path.based.cache.refresh.interval.ms</name>` |br| 
      :command:`<value>300000</value>` |br| 
   :command:`</property>`

+ *dfs.time.between.resending.caching.directives.ms* NameNode использует это значение как количество миллисекунд между повторным кэшированием директивов. Пример:

  :command:`<property>` |br| 
      :command:`<name>dfs.time.between.resending.caching.directives.ms</name>` |br| 
      :command:`<value>300000</value>` |br| 
   :command:`</property>`

+ *dfs.datanode.fsdatasetcache.max.threads.per.volume* DataNode использует это значение как максимальное количество потоков на единицу объема для кэширования новых данных. По умолчанию этот параметр имеет значение *4*. Пример:

  :command:`<property>` |br| 
      :command:`<name>dfs.datanode.fsdatasetcache.max.threads.per.volume</name>` |br| 
      :command:`<value>4</value>` |br| 
   :command:`</property>` 
   
+ *dfs.cachereport.intervalMsec* DataNode использует это значение как число миллисекунд между отправкой отчета о состоянии кэша в NameNode. По умолчанию этот параметр установлен на *10000*, что составляет 10 секунд. Пример:   

  :command:`<property>` |br| 
      :command:`<name>dfs.cachereport.intervalMsec</name>` |br| 
      :command:`<value>10000</value>` |br| 
   :command:`</property>` 

+ *dfs.namenode.path.based.cache.block.map.allocation.percent* Процент Java heap, распределенный по картам кэшированных блоков. Карта кешированных блоков - это хеш-карта, которая использует связанное хэширование. Доступ к меньшим картам осуществляется медленнее, чем если количество кешированных блоков велико; большие карты потребляют больше памяти. Значение по умолчанию - *0,25* процента. Пример:

  :command:`<property>` |br| 
      :command:`<name>dfs.namenode.path.based.cache.block.map.allocation.percent</name>` |br| 
      :command:`<value>0.25</value>` |br| 
   :command:`</property>` 


Ограничения ОС
^^^^^^^^^^^^^^

Если выдается сообщение об ошибке *"Cannot start datanode because the configured max locked memory size... is more than the datanode's available RLIMIT_MEMLOCK ulimit"*, это означает, что операционная система накладывает более низкое ограничение на объем памяти, который можно заблокировать, чем настроено. Чтобы исправить это, необходимо настроить значение *ulimit -l*, с которым работает **DataNode**. Это значение обычно настраивается в файле */etc/security/limits.conf* (может варьироваться в зависимости от используемой ОС и дистрибутива).

Вы узнаете, что значение настроено правильно, когда сможете запустить *ulimit-l* из оболочки и получить либо более высокое значение, чем настроенное, либо строку "unlimited", что указывает на отсутствие ограничения.

.. important:: Для *ulimit -l* характерно выводить ограничение блокировки памяти в килобайтах (КБ), но при этом *dfs.datanode.max.locked.memory* должно быть указано в байтах.

Например, значение *dfs.datanode.max.locked.memory* установлено в *128000* байт:

:command:`<property>` |br| 
    :command:`<name>dfs.datanode.max.locked.memory</name>` |br| 
    :command:`<value>128000</value>` |br| 
:command:`</property>` 

Лучше установить *memlock* (максимальное адресное пространство с закрытой памятью) на несколько большее значение. Например, чтобы установить *memlock* на *130 KB* (*130 000 байт*) для пользователя *hdfs*, необходимо добавить следующую строку в */etc/security/limits.conf*:

:command:`hdfs             -       memlock         130`

.. important:: Информация в данном разделе не применяется к развертыванию в Windows. Windows не имеет прямого эквивалента *ulimit -l*.



Использование Cache Pools и Directives
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Можно использовать **интерфейс командной строки** (**CLI**) для создания, изменения и перечисления **Cache Pools** и **Cache Directives** с помощью подкоманды *hdfs cacheadmin*.

**Cache Directives** идентифицируются уникальным не повторяющимся 64-битным ID. Идентификаторы не используются повторно, даже если **Cache Directive** удалена.

**Cache Pools** идентифицируются по уникальному именю строки.

Сначала следует создать **Cache Pools**, а затем добавить в него **Cache Directives**.



Команды Cache Pools
^^^^^^^^^^^^^^^^^^^


addPool
~~~~~~~

Команда добавления нового **Cache Pool**:

:command:`hdfs cacheadmin -addPool <name> [-owner <owner>] [-group <group>]` |br| 
:command:`[-mode <mode>] [-limit <limit>] [-maxTtl <maxTtl>]`


Функции команды *addPool* описаны в таблице 4. 

.. csv-table:: Табл. 4. Функции команды addPool
   :header: "Функция", "Описание"
   :widths: 10, 30

   "<name>", "Имя нового Cache Pool"
   "<owner>", "Имя пользователя владельца Cache Pool. По умолчанию используется текущий пользователь"
   "<group>", "Группа, которой назначен Cache Pool. По умолчанию используется имя основной группы текущего пользователя"
   "<mode>", "Восьмеричные разрешения в стиле UNIX, назначенные Cache Pool. По умолчанию установлены *0755*"
   "<limit>", "Максимальное количество байтов, которые в совокупности могут быть кэшированы директивами в Cache Pool. По умолчанию ограничение не установлено"
   "<maxTtl>", "Максимальное допустимое время ожидания для директив, добавляемых в Cache Pool. Значение может быть указано в секундах, минутах, часах и днях, например, *120 с*, *30 м*, *4 ч*, *2 д*. Допустимыми единицами являются *[smhd]*. По умолчанию максимальное значение не задано. Значение *never* указывает, что предела нет"



modifyPool
~~~~~~~~~~

Команда изменения метаданных существующего **Cache Pool**:

:command:`hdfs cacheadmin -modifyPool <name> [-owner <owner>] [-group <group>]` |br| 
:command:`[-mode <mode>] [-limit <limit>] [-maxTtl <maxTtl>]`


Функции команды *modifyPool* описаны в таблице 5. 

.. csv-table:: Табл. 5. Функции команды removePool
   :header: "Функция", "Описание"
   :widths: 10, 30

   "<name>", "Имя требующего изменения Cache Pool"
   "<owner>", "Имя пользователя владельца Cache Pool"
   "<group>", "Группа, которой назначен Cache Pool"
   "<mode>", "Восьмеричные разрешения в стиле UNIX, назначенные Cache Pool"
   "<limit>", "Максимальное количество байтов, которые в совокупности могут быть кэшированы директивами в Cache Pool"
   "<maxTtl>", "Максимальное допустимое время ожидания для директив, добавляемых в Cache Pool. Значение может быть указано в секундах, минутах, часах и днях, например, *120 с*, *30 м*, *4 ч*, *2 д*. Допустимыми единицами являются *[smhd]*. По умолчанию максимальное значение не задано. Значение *never* указывает, что предела нет"



removePool
~~~~~~~~~~

Команда удаления **Cache Pool**. Также удаляет пути, связанные с ним:

:command:`hdfs cacheadmin -removePool <name>`

Функции команды *removePool* описаны в таблице 6. 

.. csv-table:: Табл. 6. Функции команды removePool
   :header: "Функция", "Описание"
   :widths: 10, 30

   "<name>", "Имя удаляемого Cache Pool"



listPools
~~~~~~~~~

Команда отображает информацию об одном или нескольких **Cache Pool**, например, имя, владельца, группу, разрешения и прочее:

:command:`hdfs cacheadmin -listPools [-stats] [<name>]`

Функции команды *listPools* описаны в таблице 7. 

.. csv-table:: Табл. 7. Функции команды listPools
   :header: "Функция", "Описание"
   :widths: 10, 30

   "<-stats>", "Отображение дополнительной статистики по Cache Pool"
   "<name>", "Если параметр задан, то выдается только упомянутый Cache Pool"



help
~~~~

Отображает подробную информацию о команде:

:command:`hdfs cacheadmin -help <command-name>`

Функции команды *help* описаны в таблице 8. 

.. csv-table:: Табл. 8. Функции команды help
   :header: "Функция", "Описание"
   :widths: 10, 30

   "<command-name>", "Отображение подробной информации по указанной команде. Если команда не указана, отображается подробная справка по всем командам"



Команды Cache Directives
^^^^^^^^^^^^^^^^^^^^^^^^


addDirective
~~~~~~~~~~~~

Команда добавления нового **Cache Directive**:

:command:`hdfs cacheadmin -addDirective -path <path> -pool <pool-name> [-force]` |br| 
:command:`[-replication <replication>] [-ttl <time-to-live>]`

Функции команды *addDirective* описаны в таблице 9. 

.. csv-table:: Табл. 9. Функции команды addDirective
   :header: "Функция", "Описание"
   :widths: 10, 30

   "<path>", ""
   "<pool-name>", ""
   "<-force>", ""
   "<-replication>", ""
   "<limit>", ""
   "<time-to-live>", ""

















