Централизованное управление кэшем в HDFS
----------------------------------------

В данной главе приведены инструкции по настройке и использованию централизованного управления кэшем в **HDFS**. 
Централизованное управление кэшем позволяет указать пути к каталогам или файлам, которые будут кэшироваться **HDFS**, 
тем самым повышая производительность приложений, которые неоднократно обращаются к одним и тем же данным.



Обзор
^^^^^

Централизованное управление кэшем в **HDFS** – это точный механизм кэширования, который позволяет указывать пути к каталогам или файлам, которые будут кэшироваться **HDFS**. **NameNode** связывается с **DataNodes**, которые имеют требуемые доступные на диске блоки, и поручает **DataNodes** кэшировать блоки в кэшах.

Централизованное управление кэшем в **HDFS** дает много существенных преимуществ:

+	Точный кэш предотвращает вытеснение часто используемых данных из памяти. Это особенно важно, когда размер рабочего набора превышает размер оперативной памяти, который является общим для многих рабочих нагрузок HDFS;
+	Поскольку кэши данных DataNode управляются NameNode, приложения могут запрашивать набор местоположений кэшированных блоков при принятии решений о размещении задач. Совмещение задачи с кэшированной блочной копией повышает производительность чтения;
+	Когда блок кэшируется с помощью DataNode, клиенты могут использовать новый, более эффективный API-интерфейс с нулевой копией. Поскольку проверка контрольных сумм кэшированных данных выполняется DataNode один раз, при использовании этого нового API клиенты могут понести практически нулевые расходы;
+	Централизованное кэширование может улучшить общую эффективность использования памяти кластера. Когда используется ОС буферного кэша на каждом DataNode, повторные чтения блока приводят к тому, что все *<n>* копии блока перемещаются в буферный кэш. При централизованном управлении кэшем точно указывается только *<m>* копий *<n>*, тем самым сохраняя память *<n-m>*.



Кэширование
^^^^^^^^^^^

Централизованное управление кэшем полезно:

+	Для файлов, к которым неоднократно обращаются. Например, небольшая таблица фактов в Hive, которая часто используется, является хорошим кандидатом для кэширования. И наоборот, кэширование запроса годовой отчетности менее полезно, так как подобные данные, вероятно, могут быть прочитаны только один раз;
+	Для смешанной рабочей нагрузки с SLA-производительностью. Кэширование рабочего набора высокоприоритетной рабочей нагрузки гарантирует, что она не конкурирует с низкоприоритетными рабочими нагрузками для дискового ввода-вывода. 



Архитектура кеширования
^^^^^^^^^^^^^^^^^^^^^^^

На рисунке показана централизованная кэшированная архитектура управления (:ref:`Рис.1.<hdfsadmin_pic1>`).

.. _hdfsadmin_pic1:

.. figure:: imgs/hdfsadmin_pic1.*
   :align: center
   
   Рис.1. Архитектура кэширования
   
   
В данной архитектуре **NameNode** отвечает за координацию всех кэш-файлов с неактивными данными в кластере. **NameNode** периодически получает кэш-отчет кэш от каждого **DataNode**. Кэш-отчет описывает все блоки, кэшированные в **DataNode**. **NameNode** управляет кэшами **DataNode** с помощью кеш-копий и мгновенных команд *uncache*.

**NameNode** запрашивает набор **Cache Directives**, чтобы определить, какие контуры следует кэшировать. **Cache Directives** постоянно сохраняются в *fsimage* и журналах и могут быть добавлены, удалены и изменены с помощью **Java** и API-интерфейсов командной строки. В **NameNode** также хранится набор **Cache Pools**, являющийся административным объектом, который группирует **Cache Directives** для управления ресурсами, а также для обеспечения прав доступа.

**NameNode** периодически повторно сканирует пространство имен и актив **Cache Directives**, чтобы определить, какие блоки нужно кэшировать, а какие нет, и назначает задачи кэширования **DataNodes**. Повторное сканирование также может быть вызвано действиями пользователя, такими как добавление или удаление **Cache Directives** или удаление **Cache Pools**.

Блоки кэша, находящиеся в стадии разрабобтки, поврежденые или неполные, не кэшируются. Если **Cache Directives** содержит ссылку, адрес ссылки не кэшируется.

В настоящее время кеширование может применяться только к каталогам и файлам.



Терминология кэширования
^^^^^^^^^^^^^^^^^^^^^^^^


Cache Directive
~~~~~~~~~~~~~~~

**Cache Directive** определяет контур для кэширования. Пути могут указывать либо каталоги, либо файлы. Каталоги кэшируются не рекурсивно, то есть кэшируются только файлы в листинге каталога первого уровня.

**Cache Directives** также указывают дополнительные параметры, такие как фактор репликации кэша и время окончания. Фактор репликации указывает количество блочных реплик в кэше. Если несколько **Cache Directives** относятся к одному файлу, применяется максимальный коэффициент репликации кеша.

Время окончания задается в командной строке как время жизни (*time-to-live* - *TTL*), которое представляет собой относительное время действия в будущем. После истечения срока действия **Cache Directive** больше не учитывается **NameNode** при принятии решений кэширования.


Cache Pool
~~~~~~~~~~

**Cache Pool** - это административный объект, используемый для управления группами директив кэша. Кэш-пулы имеют UNIX-подобные разрешения, которые ограничивают доступ пользователей и групп к пулу. Разрешения на запись позволяют пользователям добавлять и удалять директивы кэша в пул. Разрешения на чтение позволяют пользователям просматривать директивы кэша в пуле и дополнительные метаданные. Execute-разрешение не используется.

**Cache Pools** также используются для управления ресурсами. Кэш-пулы могут обеспечить максимальный предел памяти, ограничивающий совокупное количество байтов, которые могут быть кэшированы директивами в пуле. Как правило, сумма лимитов пула приблизительно равна суммарной памяти, зарезервированной для кэширования **HDFS** в кластере. Кэш-пулы также мониторят ряд статистических данных, чтобы помочь пользователям кластера отслеживать, что в настоящее время кэшируется, и определить, что еще нужно кэшировать.

**Cache Pools** также могут обеспечить максимальное время жизни, ограничив максимальное время истечения срока действия директив, добавляемых в пул.



Настройка централизованного кэширования
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Собственные библиотеки
~~~~~~~~~~~~~~~~~~~~~~

Для отгорождения блокировки файлов в памяти, **DataNode** использует собственный код *JNI* из *libhadoop.so*. 
.. important:: Обязательно включите *JNI*, если используется централизованное управление кешем HDFS































