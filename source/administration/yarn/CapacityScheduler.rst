Hadoop: Capacity Scheduler
============================

В главе описывается **CapacityScheduler** -- подключаемый планировщик для **Hadoop**, позволяющий при мультитенантности безопасно совместно использовать большой кластер таким образом, чтобы для приложений своевременно распределялись ресурсы в условиях ограниченно выделенных мощностей.

**CapacityScheduler** предназначен для запуска приложений **Hadoop** в виде общего мультитенантного кластера удобным для оператора способом при максимальной пропускной способности и загрузке кластера.

Традиционно каждая организация имеет свой собственный набор вычислительных ресурсов, которые имеют достаточную производительность для соответствия SLA предприятия в пиковых или около пиковых условиях. Как правило, это приводит к низкой средней загрузке и накладным расходам на управление несколькими независимыми кластерами по одному на каждую организацию. Поэтому совместное использование кластеров между несколькими организациями -- это рентабельный способ запуска крупных Hadoop-инсталляций, так как это позволяет пользоваться преимуществами  масштаба, не создавая частных кластеров. Однако организации обеспокоены совместным использованием кластера в вопросе использования другими предприятиями ресурсов, критически важных для их собственного SLA.

**CapacityScheduler** предназначен для совместного использования большого кластера, предоставляя при этом каждой организации гарантии производительности. Основная идея заключается в том, что доступные ресурсы в кластере **Hadoop** распределяются между несколькими предприятиями. Дополнительным преимуществом является то, что организация может получить доступ к любой избыточной мощности, не используемой другими. Это обеспечивает гибкость экономически эффективным образом.

Совместное использование кластеров требует строгой мультитенантности, поскольку каждому предприятию должна быть обеспечена производительность и безопасность, чтобы гарантировать, что общий кластер защищен от любого постороннего приложения или пользователя. **CapacityScheduler** предоставляет обязательный набор ограничений, гарантирующих, что отдельное приложение, пользователь или очередь не могут использовать непропорционально большое количество ресурсов в кластере. Кроме того, для обеспечения справедливости и стабильности кластера планировщик предоставляет для инициализированных и ожидающих приложений от одного пользователя очереди и ограничения.

Основной абстракцией, предоставляемой **CapacityScheduler**, является концепция очередей. Они обычно настраиваются администраторами и отражают экономику общего кластера.

С целью дополнительного контроля и предсказуемости при совместном использовании ресурсов **CapacityScheduler** также поддерживает иерархические очереди, чтобы обеспечить распределение ресурсов между под-очередями среди приложений внутри одной организации, прежде чем другим очередям будет позволено использовать свободные ресурсы.


Функции
-----------

**CapacityScheduler** поддерживает следующие функции:

+ Иерархические очереди (Hierarchical Queues). 

Поддерживается иерархия очередей, обеспечивающая совместное использование ресурсов между под-очередями внутри организации, прежде чем другим очередям будет позволено использовать свободные ресурсы, что обеспечивает больший контроль и предсказуемость.

+ Гарантии поизводительности (Capacity Guarantees). 

Очереди распределяются по части пропускной способности сети в том смысле, что в их распоряжении находится определенная производительность ресурсов. Все приложения, отправленные в очередь, имеют доступ к производительности, выделенной для этой конкретной очереди. Для каждой очереди ограничения пропускной способности настраиваются администраторами и могут быть как мягкими, так и жесткими.

+ Безопасность (Security). 

Каждая очередь имеет строгие списки ACL, которые контролируют, какие пользователи могут отправлять приложения в отдельные очереди. Кроме того, существуют средства защиты, гарантирующие, что пользователи не смогут просматривать и/или изменять приложения других пользователей. Также поддерживаются роли для каждой очереди и системного администратора.

+ Эластичность (Elasticity). 

Свободные ресурсы могут быть распределены на любые очереди. Когда в будущем от очередей, работающих с пониженной производительностью, возникает потребность в ресурсах, то по мере выполнения запланированных на этих ресурсах задач они назначаются требуемым приложениям (также поддерживается преимущественное право). Это гарантирует, что ресурсы доступны для очередей предсказуемо и гибко, тем самым предотвращая искусственное разделение ресурсов в кластере и помогая их использованию.

+ Мультитенантность (Multi-tenancy). 

Предоставляется набор ограничений для предотвращения монополизации ресурсов очереди или кластера одним приложением, пользователем или очередью, чтобы гарантировать, что кластер не перегружен.

+ Работоспособность (Operability):

  + Конфигурация во время выполнения (Runtime Configuration) -- определения и свойства очереди, такие как производительность и списки ACL, могут быть изменены во время выполнения безопасным способом администраторами, минимизируя неудобства для пользователей. Кроме того для пользователей и администраторов предусмотрена консоль, позволяющая просматривать текущее распределение ресурсов по различным очередям в системе. Администраторы могут добавлять дополнительные очереди во время выполнения, но очереди не могут быть удалены во время выполнения, если она не остановлена и имеет ожидающие/запущенные приложения.

  + Дренаж приложений (Drain applications) -- администраторы могут останавливать очереди во время выполнения, чтобы гарантировать, что пока существующие приложения не будут завершены, новые не смогут быть направлены. Если очередь находится в состоянии *STOPPED*, новые приложения не могут быть направлены ни ей самой, ни какой-либо из ее дочерних очередей. Текущие приложения продолжают выполняться и, таким образом, очередь может быть аккуратно дренажирована. Администраторы также могут запускать остановленные очереди.

+ Планирование на основе ресурсов (Resource-based Scheduling).

Поддержка ресурсоемких приложений, в которых приложение может опционально определять более высокие требования к ресурсам, чем по умолчанию, тем самым приспосабливая приложения с различными требованиями к ресурсам. В настоящее время память является поддерживаемым требованием к ресурсам.

+ Маппинг очереди на основе пользователя или группы (Queue Mapping based on User or Group).

Функция позволяет пользователям сопоставлять работу с определенной очередью на основе пользователя или группы.

+ Приоритетное планирование (Priority Scheduling). 

Функция позволяет направлять приложения и планировать их с разными приоритетами. Более высокое целочисленное значение указывает на более высокий приоритет для приложения. В настоящее время приоритет приложения поддерживается только для политики упорядочения *FIFO*.

+ Конфигурация абсолютных ресурсов (Absolute Resource Configuration).

Администраторы могут указывать абсолютные ресурсы для очереди вместо предоставления значений в процентах. Это обеспечивает лучший контроль для администраторов в целях настройки необходимого количества ресурсов для конкретной очереди.

+ Динамическое автоматическое создание и управление конечными очередями (Dynamic Auto-Creation and Management of Leaf Queues). 

Функция поддерживает автоматическое создание конечных очередей в сочетании с маппингом очередей, которое в настоящее время поддерживает сопоставления очередей на основе групп пользователей для размещения приложений в очереди. Планировщик также поддерживает управление производительностью для этих очередей на основе политики, настроенной в родительской очереди.


Конфигурация
----------------

Чтобы настроить **ResourceManager** для использования **CapacityScheduler**, необходимо установить в файле *conf/yarn-site.xml* свойство ``yarn.resourcemanager.scheduler.class`` со значением ``org.apache.hadoop.yarn.server.resourcemanager.scheduler.capacity.CapacityScheduler``.

*etc/hadoop/capacity-scheduler.xml* -- это файл конфигурации для **CapacityScheduler**.

**CapacityScheduler** имеет предопределенную очередь с именем *root*, все очереди в системе являются дочерними по отношению к ней. Очереди можно настроить в ``yarn.scheduler.capacity.root.queues`` со списком дочерних очередей, разделенных запятыми.

Конфигурация для **CapacityScheduler** для настройки иерархии очередей использует концепцию, называемую *путь к очереди* (*queue path*). Путь к очереди -- это полный путь иерархии очереди, начиная с *root*, со знаком точки ``.`` в качестве разделителя.

Дочерние элементы очереди могут быть определены с помощью настройки ``yarn.scheduler.capacity.<queue-path>.queues``. Дочерние очереди при этом не наследуют свойства напрямую от родителя, если не указано иное.

Пример с тремя дочерними очередями верхнего уровня *a*, *b* и *c* и некоторыми подпоследовательностями для *a* и *b*:

::

 <property>
   <name>yarn.scheduler.capacity.root.queues</name>
   <value>a,b,c</value>
   <description>The queues at the this level (root is the root queue).
   </description>
 </property>
 
 <property>
   <name>yarn.scheduler.capacity.root.a.queues</name>
   <value>a1,a2</value>
   <description>The queues at the this level (root is the root queue).
   </description>
 </property>
 
 <property>
   <name>yarn.scheduler.capacity.root.b.queues</name>
   <value>b1,b2,b3</value>
   <description>The queues at the this level (root is the root queue).
   </description>
 </property>






Changing Queue Configuration
------------------------------




Updating a Container (Experimental - API may change in the future)
--------------------------------------------------------------------
