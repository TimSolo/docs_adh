Основные концепции Arenadata Grid
---------------------------------

**Платформа базы данных, ориентированная на память, кэширование и обработку данных**

**Arenadata Grid** (**ADG**) -- это ориентированная на память распределенная база данных для транзакционных, аналитических и потоковых рабочих  нагрузок, обеспечивающая скорость в памяти в масштабе петабайтов.

+ `Факты об Arenadata Grid`_
+ `Клиенты и серверы`_


Факты об Arenadata Grid
^^^^^^^^^^^^^^^^^^^^^^^

+ Является ли Grid персистентным хранилищем или это только память?

И то и другое. Локальное персистирование в **Grid** может быть включено и выключено. Это позволяет платформе хранить больше наборов данных, чем может поместиться в доступной памяти. По сути, меньшие операционные наборы данных могут храниться только в памяти, а большие наборы данных, которые не вписываются в память, могут храниться на диске, используя память в качестве слоя кэширования для лучшей производительности.

+ Является ли Grid in-memory database (IMDB)?

Да. Несмотря на то, что durable memory **Grid** хорошо работает в памяти и на диске, персистирование диска может быть отключено, а **Grid** может выступать в качестве распределенной базы данных в памяти, с поддержкой **SQL** и распределенных соединений.

+ Является ли Grid in-memory data grid (IMDG)?

Да. **Grid** -- это полнофункциональная сетка данных, которая может использоваться либо в режиме только памяти, либо с использованием локальной персистентности. **Grid** также может автоматически интегрироваться с любыми сторонними базами данных, включая любые СУБД или хранилища **NoSQL**.

+ Является ли Grid распределенным кэшем?

Да. Когда локальная персистентность отключена, **Grid** становится распределенным кэшем. **Grid** реализует спецификацию **JCache** (**JSR 107**) и обеспечивает гораздо больше функциональности, чем требуется спецификацией, включая режимы раздельного и реплицированного распространения, распределенные транзакции **ACID**, SQL-запросы, локальную персистентность и т.д.

+ Является ли Grid распределенной базой данных?

Да. Данные в **Grid** секционируются или реплицируются в кластере из нескольких узлов. Это обеспечивает масштабируемость и повышает устойчивость системы. **Grid** автоматически контролирует разделение данных, однако, пользователи могут подключать свои собственные функции распределения (affinity) и совместно использовать разные части данных для повышения эффективности.

+ Является ли Grid базой данных SQL?

Не в полной мере. Хотя **Grid** стремится вести себя как любая другая реляционная база данных **SQL**, существуют различия в том, как **Grid** обрабатывает ограничения и индексы. **Grid** поддерживает первичные и вторичные индексы, однако уникальность может быть применена только для первичных индексов. **Grid** также не поддерживает ограничения внешнего ключа.

По сути, **Grid** намеренно не поддерживает никаких ограничений, которые повлекли бы за собой рассылку сообщений о каждом обновлении кластера и значительно ухудшают производительность и масштабируемость системы.

+ Является ли Grid базой данных NoSQL?

Не совсем. Как и другие базы данных **NoSQL**, **Grid** высокодоступен и масштабируется по горизонтали. Однако, в отличие от других баз данных **NoSQL**, **Grid** поддерживает транзакции **SQL** и **ACID**.

+ Является ли Grid транзакционной базой данных?

Не в полной мере. Транзакции **ACID** поддерживаются, но только на уровне **API** с ключом. **Grid** также поддерживает транзакции между разделами, что означает, что транзакции могут охватывать ключи, находящиеся в разных разделах на разных серверах.

На уровне **SQL** **Grid** поддерживает атомарную, но еще не транзакционную согласованность. Реализация SQL-транзакции планируется в версии *2.4*.

+ Является ли Grid основой для нескольких моделей?

Да. **Grid** поддерживает как ключ-значение, так и **SQL** для моделирования и доступа к данным. Кроме того, **Grid** предоставляет надежную обработку **API** для вычисления распределенных данных.

+ Является ли Grid хранилищем ключ-значений?

Да. **Grid** предоставляет многофункциональный ключ-значение **API**, который совместим с **JCache** (**JSR-107**) и поддерживает **Java**, **C++** и **.NET**.

+ Что такое долговременная память (durable memory)?

Архитектура долговременной памяти позволяет **Grid** расширять память на диск. Это основано на выделении памяти при ее распределении, которая становится долговоременной, сохраняясь сначала в журнале записи (**WAL**), а затем в основном постоянном хранилище **Grid**. Когда персистентность отключена, долговременная память действует как простое хранилище.

+ Что такое совмещенная обработка?

**Grid** -- это распределенная система, и поэтому важно иметь возможность совмещать данные с данными и компьютер с данными, чтобы избежать шума данных. Совмещенная обработка данных становится особенно важной при выполнении распределенных SQL-соединений. **Grid** также поддерживает отправку пользовательской логики (функции, лямбды и т.д.) непосредственно к узлам, где данные хранятся и вычисляются локально.



Клиенты и серверы
^^^^^^^^^^^^^^^^^

**Автоматическое различие клиентских и серверных узлов**

**Grid** имеет необязательное понятие клиентских и серверных узлов. Серверные узлы участвуют в кэшировании, расчете исполнения, обработке потока и т.д., в то время как собственные клиентские узлы обеспечивают возможность удаленного подключения к серверам. Собственные клиенты **Grid** позволяет использовать весь набор API-интерфейсов **ADG** с клиентской стороны, включая кэширование, транзакции, вычисления, потоковые передачи, службы и т.д..

По умолчанию все узлы **Grid** запускаются как узлы сервера, а режим клиента должен быть включен.


Настройка клиентов и серверов
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Настроить узел как клиент или сервер можно через свойство *IgniteConfiguration.setClientMode(...)*:

+ XML:

  ::
  
   <bean class="org.apache.ignite.configuration.IgniteConfiguration">
       ...   
       <!-- Enable client mode. -->
       <property name="clientMode" value="true"/>
       ...
   </bean>

+ Java:

  ::
  
   IgniteConfiguration cfg = new IgniteConfiguration();
   
   // Enable client mode.
   cfg.setClientMode(true);
   
   // Start Ignite in client mode.
   Ignite ignite = Ignition.start(cfg);

Кроме того, для удобства также можно включить или отключить режим клиента в классе *Ignition*, чтобы клиенты и серверы использовали одну и ту же конфигурацию: 

+ Java:

  ::
  
   Ignition.setClientMode(true);
   
   // Start Ignite in client mode.
   Ignite ignite = Ignition.start();


Создание распределенных кэшей
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Всякий раз при создании кэшей в **Grid** в **XML** либо при помощи метода *Ignite.createCache(...)* или *Ignite.getOrCreateCache(...)*, **ADG** автоматически развертывает распределенный кэш на всех узлах сервера. 

.. important:: Как только распределенный кэш будет создан, он будет автоматически развернут на всех существующих и будущих узлах сервера

+ Java:

  ::
  
   // Enable client mode locally.
   Ignition.setClientMode(true);
   
   // Start Ignite in client mode.
   Ignite ignite = Ignition.start();
   
   CacheConfiguration cfg = new CacheConfiguration("myCache");
   
   // Set required cache configuration properties.
   ...
   
   // Create cache on all the existing and future server nodes.
   // Note that since the local node is a client, it will not 
   // be caching any data.
   IgniteCache<?, ?> cache = ignite.getOrCreateCache(cfg);


Вычисление на клиентах или серверах
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

По умолчанию *IgniteCompute* выполняет задания на всех узлах сервера. Но при этом можно выбрать выполнение заданий только на узлах сервера или только на клиентских узлах, создав соответствующую группу кластеров:

+ Compute on Servers:

  ::
  
   IgniteCompute compute = ignite.compute();
   
   // Execute computation on the server nodes (default behavior).
   compute.broadcast(() -> System.out.println("Hello Server"));

+ Compute on Clients:

  ::
  
   ClusterGroup clientGroup = ignite.cluster().forClients();
   
   IgniteCompute clientCompute = ignite.compute(clientGroup);
   
   // Execute computation on the client nodes.
   clientCompute.broadcast(() -> System.out.println("Hello Client"));


Управление медленными клиентами (Slow Clients)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~









