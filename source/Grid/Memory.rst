Durable Memory
--------------

Durable Memory
^^^^^^^^^^^^^^

Ориентированная на память платформа **Arenadata Grid** основана на долговременной архитектуре памяти, которая позволяет хранить и обрабатывать данные и индексы как в памяти, так и на диске (при включенной функции `Grid Native Persistence`_). Архитектура Durable Memory помогает достичь функционирование памяти эффективней дисковой, используя все доступные ресурсы кластера.

Долговременная память **Grid** работает аналогично виртуальной памяти операционных систем (таких как **Linux**). Однако, одно существенное различие между этими двумя типами архитектуры заключается в том, что долговременная память при включенной персистентности всегда обрабатывает диск как надмножество данных, способное выдержать сбои и перезагрузки, в то время как традиционная виртуальная память использует диск только в качестве пространства подкачки памяти, которое очищается после завершения процесса.


Функции In-Memory
~~~~~~~~~~~~~~~~~

Поскольку архитектура ориентирована на память, оперативная память всегда рассматривается как первый уровень, где происходит вся обработка. Далее приведены характеристики и преимущества архитектуры в части in-memory:

+ **Off-heap Based** -- все данные и индексы хранятся вне **Java heap**, что позволяет легко обрабатывать петабайты данных, находящихся в кластере;
+ **Removes Noticeable Garbage Collection Pauses** -- поскольку все данные и индексы хранятся off-heap, код приложения является единственным возможным источником для длительных пауз;
+ **Предсказуемое использование памяти** -- по умолчанию долговременная память использует как можно больше RAM и дискового пространства. Тем не менее, можно легко настроить использование памяти в соответствии с необходимыми требованиями приложения;
+ **Автоматическая дефрагментация памяти** -- **Arenadata Grid** использует память как можно более эффективно и выполняет процедуры дефрагментации в фоновом режиме, избегая фрагментации;
+ **Повышенная производительность и использование памяти** -- все данные и индексы хранятся в постраничном формате с аналогичным представлением в памяти и на диске, что устраняет необходимость сериализации или десериализации данных.


Функции персистентности
~~~~~~~~~~~~~~~~~~~~~~~

В данном разделе описываются параметры персистентности в **Grid**:

+ `Grid Native Persistence`_
+ `Сторонняя персистентность`_
+ `Пространство подкачки памяти`_


Grid Native Persistence
````````````````````````

*Grid Persistence* -- это наиболее гибкий, масштабируемый и удобный способ хранения данных в **ADG**. Он широко используется в сценариях, где приложениям требуется распределенная база данных, ориентированная на память. Преимущества следующие:

+ **Устойчивость Данных**. Поскольку на уровне *Grid persistent* хранится полный набор данных, он может выдержать сбои и перезапуски кластера без потери данных и с сохранением высокой устойчивости транзакций;
+ **Кэш только горячих данных в памяти**. Хранение надмножества данных на диске и подмножества данных в памяти. При включенной функции *Grid Native Persistence* нет необходимости помещать все данные в RAM. Долговременная память сохраняет горячие данные в RAM, автоматически очищая холодные данные из памяти, когда больше не остается места;
+ **Выполнение SQL по всем наборам данных**. Большинство in-memory систем могут запрашивать данные только в том случае, когда они предварительно загружены в память, поэтому ограничение размера данных зависит только от размера памяти. **Grid SQL** всегда охватывает весь распределенный персистентный набор данных, используя кэш in-memory для повышения производительности;
+ **Мгновенный перезапуск кластера**. Если весь кластер выходит из строя, он может перезагрузиться и сразу же начать работу. In-memory кэш автоматически разогревается по мере доступа к данным.


Сторонняя персистентность
``````````````````````````

**ADG** может использоваться как слой кэширования (сетка данных) над сторонней базой данных -- **RDBMS**, **NoSQL** или **HDFS**. Этот режим используется для ускорения основной БД, в которой сохраняются данные. **Grid** хранит данные в памяти, распределенной по нескольким узлам, обеспечивая быстрый доступ к данным. Это снижает нагрузку на сеть, вызванную частым перемещением данных между приложением и БД.

Однако существуют некоторые ограничения по сравнению с собственной персистентностью. Например, SQL-запросы выполняются только по данным, находящимся в оперативной памяти, что требует предварительную загрузку всего набора данных с диска в память.


Пространство подкачки памяти
````````````````````````````

Вместо использования персистентности **Grid** или сторонней персистентности, можно включить swapping (подкачку), и в таком случае при исчерпанной памяти **RAM** данные из in-memory **Grid** перемещаются в пространство подкачки, расположенное на диске. При включенном пространстве подкачки (swap space), **ADG** хранит данные в файлах с отображением в памяти (memory mapped files, **MMF**), содержимое которых может перемещаться с ОС на диск в зависимости от текущего потребления **RAM**.

Swap space в основном используется во избежание ошибок в памяти (out of memory errors, **OOME**), которые могут произойти, если потребление оперативной памяти превышает ее емкость, потребуется больше времени для масштабирования кластера с целью равномерного распределения наборов данных.


Архитектура памяти
^^^^^^^^^^^^^^^^^^

**Grid Durable Memory** -- это архитектура памяти на постраничной основе, разбитая на страницы фиксированного размера. Страницы хранятся в управляемых областях off-heap в **RAM** (вне **Java heap**) и организованы в особой иерархии на диске.

**Grid** поддерживает то же представление двоичных данных как в памяти, так и на диске, что устраняет необходимость дорогостоящей сериализации при перемещении данных между памятью и диском.

+ `Область данных`_
+ `Оперативные и исторические данные`_
+ `Сегмент памяти`_
+ `Страницы данных`_
+ `B+ деревья и индексные страницы`_
+ `Свободные списки`_


Область данных
~~~~~~~~~~~~~~

Область данных -- это логически расширяемая область. Долговременная память может состоять из одной или нескольких областей данных, которые могут различаться по размеру и политике, персистироваться на диск и иметь другие отличия.

По умолчанию **Grid** выделяет одну область данных, занимающую до *20%* оперативной памяти, доступной на локальном узле кластера.


Оперативные и исторические данные
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Для лучшей производительности следует хранить оперативные данные в памяти. Для этого необходимо настроить несколько областей памяти.

Например, предположим, что имеются объекты *Person*, *Purchases* и *Records*, хранящиеся в *PersonCache*, *PurchasesCache* и *RecordsCache* соответственно. Данные о лицах и закупках являются оперативными, то есть данными, к которым часто обращаются. А данные записей -- исторические, доступ к ним осуществляется реже.

Теперь предположим, что есть только *200 ГБ* оперативной памяти. В этом случае физическую память можно разделить следующим образом:

+ *190 ГБ* на создание области для оперативных или часто используемых данных, таких как *Person* и *Purchases*. Таким образом, *PersonCache* и *PurchaseCache* получают максимальную производительность из кластера;
+ *10 ГБ* на выделение области для исторических или редко используемых наборов данных, таких как *RecordsCache*, данные которого размещаются на диске.


Сегмент памяти
~~~~~~~~~~~~~~

Каждая область данных начинается с исходного размера и имеет максимальный размер, до которого может вырасти. Область расширяется до максимальной границы, выделяя сегменты непрерывной памяти. По умолчанию максимальный размер области равен 20% объема **RAM**, доступного в системе.

Сегмент памяти представляет собой непрерывный массив байтов или физическую память, выделенную из операционной системы. Массив разделяется на страницы фиксированного размера. Существует несколько типов страниц, которые могут находиться в сегменте.


Страницы данных
~~~~~~~~~~~~~~~

Страница данных хранит записи, помещенные в кэш **ADG** со стороны приложения.

Как правило, одна страница данных содержит несколько записей ключ-значение для того, чтобы использовать память как можно более эффективно и избежать фрагментации памяти. Когда новая запись добавляется в кэш, **Grid** выполняет поиск оптимальной страницы, которая может соответствовать всей записи ключ-значение.

Однако, если общий размер записи превышает размер страницы, настроенный с помощью параметра *DataStorageConfiguration.setPageSize(..)*, то запись занимает более одной страницы данных.



B+ деревья и индексные страницы
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Все индексы **SQL**, определенные и используемые в приложении, поддерживаются в древовидной структуре данных *B+*. Для каждого уникального индекса в схеме **SQL**, **Grid** создает и управляет выделенным экземпляром дерева *B+*.

Кэшированные ключи также хранятся в деревьях *B+* и упорядочены по их значениям хэш-кода.

Цель дерева *B+* состоит в том, чтобы связать и упорядочить индексные страницы, которые выделяются и хранятся в долговременной памяти. В индексной странице содержится вся информация, необходимая для определения индексированного значения и перемещения записи на странице данных, а также ссылки на другие индексные страницы дерева.

**B+ tree Meta Page** необходима, чтобы добраться до корня конкретного дерева *B+* и его слоев, для эффективного выполнения ряда запросов. Например, при выполнении операции *myCache.get(keyA)*, вызывается следующий поток действий:

1. **Grid** выполняет поиск области памяти, к которой принадлежит *myCache*;
2. Размещается мета-страница, указывающая на хэш-индекс *B+* дерева *myCache*;
3. На основе хэш-кода *keyA* индексная страница, к которой принадлежит ключ, располагается в дереве *B+*;
4. Если соответствующая индексная страница не найдена в памяти или на диске, **Grid** делает вывод о том, что ключ не существует, и выдает значение *null*;
5. Если индексная страница существует, то она содержит всю информацию, необходимую для поиска страницы данных кэша *keyA*;
6. **Grid** находит страницу данных для *keyA* и выдает значение пользователю.


Свободные списки
~~~~~~~~~~~~~~~~

Вышеуказанный поток выполнения объясняет, как кэш просматривается в памяти страницы. Теперь перейдем к тому, как **Grid** сохраняет новую запись кэша при выполнении такой операции, как *myCache.put (keyA, valueA)*.

В этом случае долговременная память основывается на структуре свободных списков. Свободный список -- это двунаправленный список, в котором хранятся ссылки на страницы памяти примерно равного свободного места. Страницы данных и индексов отслеживаются в разных свободных списках.

Далее приведен поток выполнения операции *myCache.put (keyA, valueA)*:

1. **Grid** выполняет поиск области памяти, к которой принадлежит *myCache*;
2. Размещается мета-страница, указывающая на хэш-индекс *B+* дерева *myCache*;
3. На основе хэш-кода *keyA* индексная страница, к которой принадлежит ключ, располагается в дереве *B+*;
4. В случае если соответствующая индексная страница не найдена в памяти или на диске, запрашивается новая страница у одного из свободных списков. Как только индексная страница будет предоставлена, она добавляется в дерево *B+*;
5. Если индексная страница пуста (т.е. не относится ни к одной странице данных), то страница данных предоставляется одним из свободных списков в зависимости от общего размера записи кэша. Ссылка на страницу данных добавляется на индексную страницу;
6. Запись кэша добавляется на страницу данных.



Конфигурация памяти
^^^^^^^^^^^^^^^^^^^

